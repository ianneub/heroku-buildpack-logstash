input {
  s3 {
    bucket => "papertrail.steller.co"
    prefix => "papertrail/logs/3132014"
    sincedb_in_s3_bucket => "papertrail.steller.co"
    sincedb_path => "sincedb"
    credentials => ["AKIAJA2XWST5HPKX2ODA", "RUaKfG7+B9ZiHTh+LevNJzlKbcJesUATBPzWZC7o"]
  }
}

output {
  # connectoid to the found.no steller logs cluster
  elasticsearch_http {
    host => "2b12e09a66c713b343d6d56b14924823-us-east-1.foundcluster.com"
    port => 9200
    user => "readwrite"
    password => "9r6qcgqfqiatcjrhdf"
    template => "./elasticsearch-template.json"
  }
}

filter {

  # set host to the heroku dyno IP?
  mutate {
    remove_field => ["host"]
  }

  # kill everything but prod - later, if it makes sense, we can
  # create distinct indicies for prod vs. dev
  # capture the papertrail prefix properites
  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{PAPERTRAIL_PREFIX}" }
  }
  date {
    match => ["ts", "ISO8601"]
    timezone => "UTC"
  }

  if [api_source] != "print-api" {
    drop {}
  }
  # mark print-api as prod-print-api to make filtering more robust
  mutate {
    gsub => [
      "api_source", "^print-api$", "prod-print-api"
    ]
  }

  # check for this being a request log
  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{REQUEST_LOG}" }
    tag_on_failure => ["not_api"]
    add_field => ["isapi", "true"]
    break_on_match => true
  }

  if [isapi] != "true" {
    drop {}
  } else {
    mutate {
      remove_field => ["isapi"]
    }
  }

  # then pick up request metadata timestamp, auth_user, duration, and status
  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{API_TIMESTAMP:call_time}" }
  }

  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{AUTH_USER_DATA}" }
    tag_on_failure => []
  }
  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{AUTH_USER_WITH_NAME}" }
    tag_on_failure => []
  }

  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{API_META_DATA}" }
    tag_on_failure => []
  }

  # pick up primary id's, e.g., /v1/stories/{id}
  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{PRIMARY_IDS}" }
    tag_on_failure => []
  }

  # pick up secondary id's, e.g., /v1/stories/{id}/likes/{id}
  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{SECONDARY_IDS}" }
    tag_on_failure => []
  }

  # process [uid: id,name] IF after doing this there is no user_name, it means
  # this pattern wasn't found. If this is the case, then if there is a user_id
  # and an auth_user it means the rest URL contains a primary id. If the id's
  # are the same then set the username property
  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{USER_WITH_NAME}" }
    tag_on_failure => []
  }
  if ![user_name] {
    if [user_id] and [auth_user] and [auth_user_name] and [user_id] == [auth_user] {
      mutate {
        add_field => {
          "user_name" => "%{[auth_user_name]}"
        }
      }
    }
  }
  # if the rest url pattern came with a user_id, and there was also a uid annotation, then
  # drop the uid id, otherwise, if it exists set user_id and drop uid. All we are trying to
  # do is avoid an array in user_id
  if [uid] and [user_name] {
    if [user_id] {
      mutate {
        remove_field => ["uid"]
      }
    } else {
      mutate {
        add_field => {"user_id" => "%{[uid]}"}
        remove_field => ["uid"]
      }
    }
  }

  # process [cid: id,username,collectionname] IF after doing this there is a cid and collection_name
  # then hoist cid to collection_id and drop cid. The point is to avoid arrays of collection_id which
  # can occur when the rest url contains a primary collection id and the logs are annotated with cid
  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{COLLECTION_WITH_NAME}" }
    tag_on_failure => []
  }
  if [cid] and [collection_name] {
    if [collection_id] {
      mutate {
        remove_field => ["cid"]
      }
    } else {
      mutate {
        add_field => {"collection_id" => "%{[cid]}"}
        remove_field => ["cid"]
      }
    }
  }

  # all the id fields end in _id, so set auth_user_id and make auth_user the blended form
  if [auth_user] {
    mutate {
      add_field => {"auth_user_id" => "%{auth_user}"}
    }
    if [auth_user_name] {
      mutate {
        remove_field => ["auth_user"]
      }
      mutate {
        add_field => {"auth_user" => "%{auth_user_id},%{auth_user_name}"}
      }
    }
  }

  # pick up VERB and PATH
  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{VERBS:raw_verb} %{URIPATH:raw_path}" }
    tag_on_failure => []
  }


  # lowercase and transform verbs
  mutate {
    add_field => {
      "path" => "%{raw_path}"
      "verb" => "%{raw_verb}"
    }
  }

  mutate {
    lowercase => ["raw_verb"]
  }

  # make singular id based paths: /v1/stories/{id} --> /v1/story/{id} so that once
  # id's are stripped with see get_v1_stories vs. get_v1_story
  mutate {
    gsub => [
      "raw_path", "/v1/collections/\d+", "/v1/collection/",
      "raw_path", "/v1/stories/\d+", "/v1/story/",
      "raw_path", "/v1/templates/\d+", "/v1/template/",
      "raw_path", "/v1/users/\d+", "/v1/user/"
    ]
  }

  # convert verb/path to api call:
  # e.g. GET /v1/stories/{id} --> get_v1_stories_by_id
  mutate {
    gsub => [
      # rename put to update
      "raw_verb", "put", "update",
      "raw_verb", "post", "create",

      # remove id's from path and _ seperate
      "raw_path", "/\d+/", "/",
      "raw_path", "/\d+", "",
      "raw_path", "//", "/",
      "raw_path", "/$", "",
      "raw_path", "/", "_"
    ]
  }

  # flatten verb and path to single API call
  mutate {
    add_field => {
      "api" => "%{raw_verb}%{raw_path}"
      "request" => "%{verb} %{path}"
    }
    remove_field => ["raw_verb", "raw_path", "verb", "path", "ts"]
  }

  # fix up creates to singularize
  mutate {
    gsub => [
      "api", "create_v1_collections", "create_v1_collection",
      "api", "create_v1_stories", "create_v1_story",
      "api", "create_v1_templates", "create_v1_template",
      "api", "create_v1_users", "create_v1_user"
    ]
  }

  mutate {
    remove_field => ["message"]
  }
}
