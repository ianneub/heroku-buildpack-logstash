input {
  s3 {
    bucket => "papertrail.steller.co"
    prefix => "papertrail/logs/3132014"
    credentials => ["AKIAJA2XWST5HPKX2ODA", "RUaKfG7+B9ZiHTh+LevNJzlKbcJesUATBPzWZC7o"]
  }
#  s3 {
#    bucket => "papertrail.steller.co"
#    prefix => "testfiles"
#    credentials => ["AKIAJA2XWST5HPKX2ODA", "RUaKfG7+B9ZiHTh+LevNJzlKbcJesUATBPzWZC7o"]
#  }
  #stdin {}
}

output {
  # connectoid to the found.no steller logs cluster
  elasticsearch_http {
    host => "2b12e09a66c713b343d6d56b14924823-us-east-1.foundcluster.com"
    port => 9200
    user => "readwrite"
    password => "9r6qcgqfqiatcjrhdf"
    template => "./elasticsearch-template.json"
  }
  # stdout { codec => rubydebug }
}

filter {

  # set host to the heroku dyno IP?
  mutate {
    remove_field => ["host"]
  }

  # kill everything but prod - later, if it makes sense, we can
  # create distinct indicies for prod vs. dev
  # capture the papertrail prefix properites
  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{PAPERTRAIL_PREFIX}" }
  }
  date {
    match => ["ts", "ISO8601"]
    timezone => "UTC"
  }

  if [api_source] != "print-api" {
    drop {}
  }
  # mark print-api as prod-print-api to make filtering more robust
  mutate {
    gsub => [
      "api_source", "^print-api$", "prod-print-api"
    ]
  }

  # check for this being a request log
  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{REQUEST_LOG}" }
    tag_on_failure => ["not_api"]
    add_field => ["isapi", "true"]
    break_on_match => true
  }

  if [isapi] != "true" {
    drop {}
  } else {
    mutate {
      remove_field => ["isapi"]
    }
  }

  # then pick up request metadata timestamp, auth_user, duration, and status
  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{API_TIMESTAMP:call_time}" }
  }

  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{AUTH_USER_DATA}" }
    tag_on_failure => []
  }
  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{API_META_DATA}" }
    tag_on_failure => []
  }

  # pick up primary id's, e.g., /v1/stories/{id}
  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{PRIMARY_IDS}" }
    tag_on_failure => []
  }

  # pick up secondary id's, e.g., /v1/stories/{id}/likes/{id}
  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{SECONDARY_IDS}" }
    tag_on_failure => []
  }

  # pick up VERB and PATH
  grok {
    patterns_dir => [ "./apipatterns" ]
    match => { "message" => "%{VERBS:raw_verb} %{URIPATH:raw_path}" }
    tag_on_failure => []
  }


  # lowercase and transform verbs
  mutate {
    add_field => {
      "path" => "%{raw_path}"
      "verb" => "%{raw_verb}"
    }
  }

  mutate {
    lowercase => ["raw_verb"]
  }

  # make singular id based paths: /v1/stories/{id} --> /v1/story/{id} so that once
  # id's are stripped with see get_v1_stories vs. get_v1_story
  mutate {
    gsub => [
      "raw_path", "/v1/collections/\d+", "/v1/collection/",
      "raw_path", "/v1/stories/\d+", "/v1/story/",
      "raw_path", "/v1/templates/\d+", "/v1/template/",
      "raw_path", "/v1/users/\d+", "/v1/user/"
    ]
  }

  # convert verb/path to api call:
  # e.g. GET /v1/stories/{id} --> get_v1_stories_by_id
  mutate {
    gsub => [
      # rename put to update
      "raw_verb", "put", "update",
      "raw_verb", "post", "create",

      # remove id's from path and _ seperate
      "raw_path", "/\d+/", "/",
      "raw_path", "/\d+", "",
      "raw_path", "//", "/",
      "raw_path", "/$", "",
      "raw_path", "/", "_"
    ]
  }

  # flatten verb and path to single API call
  mutate {
    add_field => {
      "api" => "%{raw_verb}%{raw_path}"
      "request" => "%{verb} %{path}"
    }
    remove_field => ["raw_verb", "raw_path", "verb", "path", "ts"]
  }

  # fix up creates to singularize
  mutate {
    gsub => [
      "api", "create_v1_collections", "create_v1_collection",
      "api", "create_v1_stories", "create_v1_story",
      "api", "create_v1_templates", "create_v1_template",
      "api", "create_v1_users", "create_v1_user"
    ]
  }

  mutate {
    remove_field => ["message"]
  }
}
